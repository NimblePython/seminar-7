# **Задание: Разработка графического редактора на SFML**

**Цель:**  
Создать графическую программу на C++ с использованием библиотеки SFML, которая позволяет пользователям рисовать и управлять различными графическими объектами на экране. Задание направлено на закрепление знаний по `static_cast`, `dynamic_cast`, `reinterpret_cast`, указателям на функции, созданию статических и динамических библиотек, а также основам ООП в C++.

---

## Требования к функциональности

1. **Рисование линий:**
   - Возможность рисовать линии поверх существующего контента.
   - Изменение цвета пера.
   - Изменение толщины пера.
   - Изменение прозрачности пера.

2. **Рисование фигур:**
   - **Круги:**
     - Рисование круга.
     - Возможность ввода и отображения текста внутри круга.
     - Изменение цвета и толщины границы круга.
   - **Прямоугольники:**
     - Рисование прямоугольника.
     - Возможность ввода и отображения текста внутри прямоугольника.
     - Изменение цвета и толщины границы прямоугольника.

3. **Управление объектами:**
   - Каждый отрисованный элемент (линия, круг, прямоугольник) должен быть представлен как отдельный объект класса.
   - Возможность перемещения объектов по экрану.
   - Возможность редактирования объектов (например, дорисовывание дополнительных линий).

---

## Технические требования

1. **Объектно-ориентированное программирование (ООП):**
   - Создать базовый класс `Shape` (или аналогичный), содержащий общие свойства (цвет, толщина, позиция) и виртуальные методы для отрисовки и управления.
   - Отнаследовать от базового класса конкретные классы `Line`, `Circle`, `Rectangle`, реализующие специфичное поведение.
   - Использовать полиморфизм для управления коллекцией объектов через указатели на базовый класс.

2. **Использование C++ Casts:**
   - Применять `static_cast` для безопасных преобразований между связанными типами.
   - Использовать `dynamic_cast` для проверки типа объектов во время выполнения.
   - При необходимости применять `reinterpret_cast`, обеспечивая понимание потенциальных рисков.

3. **Указатели на функции:**
   - Реализовать обработку событий (например, нажатие кнопок интерфейса) с использованием указателей на функции.
   - Создать систему обратных вызовов для действий, связанных с объектами (рисование, изменение свойств и т.д.).

4. **Создание библиотек:**
   - Разделить проект на статическую и/или динамическую библиотеку, содержащую классы графических объектов и связанные функции.
   - Подключить эту библиотеку к основному приложению, демонстрируя умение работать с библиотеками в C++.

5. **Работа с SFML:**
   - Использовать SFML для создания окна приложения, обработки событий ввода (мышь, клавиатура) и отрисовки графических объектов.
   - Обеспечить плавную работу и отзывчивость интерфейса.

6. **Дополнительные требования:**
   - Реализовать систему сохранения и загрузки созданных графических объектов (например, в файл формата JSON или XML).
   - Обеспечить пользовательский интерфейс для выбора инструментов рисования, изменения параметров пера и управления объектами.

---

## Рекомендации по реализации

1. **Структура проекта:**
   - **Библиотека (Static/Dynamic):**
     - Создать проект библиотеки, содержащей определения классов `Shape`, `Line`, `Circle`, `Rectangle` и связанных функций.
     - Определить интерфейсы и реализации в отдельных заголовочных (`.h`) и исходных (`.cpp`) файлах.
   - **Основное приложение:**
     - Создать отдельный проект, который подключает созданную библиотеку.
     - Реализовать логику взаимодействия с пользователем, отрисовку объектов и управление ими.

2. **Использование ООП:**
   - Базовый класс `Shape` может содержать чисто виртуальные методы, такие как `draw()`, `move()`, `setColor()`, и т.д.
   - Производные классы реализуют эти методы, используя возможности SFML для отрисовки.

3. **Пример использования C++ Casts:**
   - При необходимости определить тип объекта во время выполнения (например, при редактировании), использовать `dynamic_cast` для безопасного приведения.
   - Применять `static_cast` для преобразований, связанных с наследованием, когда тип известен на этапе компиляции.
   - Использовать `reinterpret_cast` только в крайних случаях, понимая возможные риски и последствия.

4. **Указатели на функции:**
   - Создать функции для обработки событий (например, `onDrawLine`, `onChangeColor`) и хранить их в виде указателей или `std::function` для динамического вызова.

5. **Работа с библиотеками:**
   - Следовать стандартным методам создания и подключения библиотек в C++ (например, используя CMake для управления сборкой).

---

## Критерии оценки

1. **Функциональность:**
   - Соответствие реализации требованиям задания.
   - Корректность работы основных и дополнительных функций.

2. **Качество кода:**
   - Читаемость и структурированность кода.
   - Правильное использование ООП принципов.
   - Эффективное применение C++ возможностей (casts, указатели на функции и т.д.).

3. **Использование библиотек:**
   - Корректная организация проекта с использованием статических/динамических библиотек.
   - Эффективное подключение и использование SFML.

4. **Пользовательский интерфейс:**
   - Удобство и интуитивность интерфейса.
   - Реализация функций сохранения и загрузки.

5. **Документация:**
   - Наличие комментариев в коде.
   - Предоставление инструкции по сборке и использованию программы.

---

## Рекомендованная структура классов

```cpp
// Shape.h
#pragma once
#include <SFML/Graphics.hpp>
#include <string>

class Shape {
public:
    virtual ~Shape() {}
    virtual void draw(sf::RenderWindow& window) = 0;
    virtual void move(float offsetX, float offsetY) = 0;
    virtual void setColor(const sf::Color& color) = 0;
    virtual void setThickness(float thickness) = 0;
    // Дополнительные методы
};

// Line.h
#pragma once
#include "Shape.h"

class Line : public Shape {
private:
    sf::VertexArray vertices;
    float thickness;
public:
    // Конструктор
    // Переопределение виртуальных методов
    // Дополнительные методы
    // Возможно деструктор
};

// Circle.h
#pragma once
#include "Shape.h"
#include <SFML/Graphics.hpp>

class Circle : public Shape {
private:
    sf::CircleShape circle;
    sf::Text text;
public:
    // Конструктор
    // Переопределение виртуальных методов
    // Дополнительные методы
    // Возможно деструктор
};

// Rectangle.h
#pragma once
#include "Shape.h"
#include <SFML/Graphics.hpp>

class Rectangle : public Shape {
private:
    sf::RectangleShape rectangle;
    sf::Text text;
public:
    // Конструктор
    // Переопределение виртуальных методов
    // Дополнительные методы
    // Возможно деструктор
};
```

---

## Полезные ресурсы

- **SFML Документация:** [https://www.sfml-dev.org/documentation/](https://www.sfml-dev.org/documentation/)
- **Файл SFML_info.MD подготовленный для данного семинара:** [https://github.com/NimblePython/seminar-7/blob/main/SFML_info.MD/](https://github.com/NimblePython/seminar-7/blob/main/SFML_info.MD)
- **Руководство по созданию библиотек в C++:** Смотрите лекции на страницах moodle университета
- **Справка по структуре программ в C++:** [LearnCpp - Static and Dynamic Libraries](https://www.learncpp.com/cpp-tutorial/introduction-to-the-compiler-linker-and-libraries/)
- **Примеры использования C++ Casts:** [cppreference.com - C++ Cast Operators](https://en.cppreference.com/w/cpp/language/explicit_cast)  
- **Уроки по C++ Casts:** [cplusplus.com - Type conversions](https://cplusplus.com/doc/tutorial/typecasting/)

---

## Срок выполнения

_До конца ноября 2024 г._

## Формат сдачи

- Исходный код проекта с понятной структурой папок.
- Инструкции по сборке и запуску программы.
- Краткая документация по использованным классам и архитектуре приложения.
- Примеры сохраненных файлов (если реализована функция сохранения).

---

## Советы по выполнению

1. **Планирование:** Начните с проектирования классов и определения их взаимодействий. Это поможет избежать переработки архитектуры в процессе разработки.

2. **Постепенная реализация:** Реализуйте функционал поэтапно — сначала базовое рисование линий, затем добавление кругов и прямоугольников, далее управление объектами и т.д.

3. **Тестирование:** Регулярно тестируйте каждую часть приложения, чтобы своевременно обнаруживать и исправлять ошибки.

4. **Использование контроля версий:** Рекомендуется использовать систему контроля версий (например, Git) для отслеживания изменений и облегчения совместной работы (если применимо).

5. **Комментарии и документация:** Пишите понятные комментарии и поддерживайте документацию актуальной, чтобы облегчить понимание кода вам и другим.
